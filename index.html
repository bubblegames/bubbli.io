<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js 
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

-->
        <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@4.2.1/dist/babylon.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@4.2.1/dist/gui/babylon.gui.min.js"></script><
        <script src= "https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@4.2.1/dist/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@4.2.1/dist/nodeEditor/babylon.nodeEditor.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@4.2.1/dist/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@4.2.1/dist/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@4.2.1/dist/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@4.2.1/dist/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@4.2.1/dist/serializers/babylonjs.serializers.min.js"></script>


        <script src="https://preview.babylonjs.com/recast.js"></script>


        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        function computeNavmesh(navigationPlugin, scene, parameters) {
            navigationPlugin.createNavMesh(scene.meshes, parameters);
            //navigationPlugin.setDefaultQueryExtent(new BABYLON.Vector3(.0001,.0001,.0001));
            let navmeshdebug = navigationPlugin.createDebugNavMesh(scene);
            let matdebug = new BABYLON.StandardMaterial('matdebug', scene);
            matdebug.diffuseColor = new BABYLON.Color3(0.1, 0.2, 1);
            matdebug.alpha = 0.2;
            navmeshdebug.material = matdebug;
        }
        
        function createGroundFromHeightMapAsync(scene) {
            return new Promise(resolve => {
                ground = BABYLON.Mesh.CreateGroundFromHeightMap(
                    "ground",
                    "/textures/heightMap.png",
                    250,
                    250,
                    200,
                    0,
                    20, scene, false, (mesh) => {
                        resolve(mesh);
                    }
                );
            });
        }
        
        function getGroundPosition(scene) {
            //return new BABYLON.Vector3(-18, 30, 9);
            var pickinfo = scene.pick(scene.pointerX, scene.pointerY);
            if (pickinfo.hit) {
                return pickinfo.pickedPoint;
            }
            return null;
        }
        
        var agentsMeta = [];
        var numAgents = 10;
        var playerAgentIdx = 0;
        
        var pathLine;
        function pointerDown(mesh, crowd, navigationPlugin, scene) {
            let startingPoint = getGroundPosition(scene);
            let playerDestPos = navigationPlugin.getClosestPoint(startingPoint);
            crowd.agentGoto(playerAgentIdx, playerDestPos);
            /*
            var pathPoints = navigationPlugin.computePath(crowd.getAgentPosition(playerAgentIdx), playerDestPos);
            pathLine = BABYLON.MeshBuilder.CreateDashedLines("ribbon", { points: pathPoints, updatable: true, instance: pathLine }, scene);
            pathLine.refreshBoundingInfo();
            */
        }
        
        function wander(crowd, navigationPlugin, playerMode, scene) {
            let agents = crowd.getAgents();
            for (i = 0; i < agents.length; i++) {
                let agentIdx = agents[i];
        
                if (agentIdx == playerAgentIdx) {
                    // player controlled by mouse click, skipping...
                    continue;
                }
        
                let agentObj = agentsMeta[i];
                let currAgentPos = crowd.getAgentPosition(i);
                let playerPos = crowd.getAgentPosition(agents[playerAgentIdx]);
        
                let fleeDistance = 3;
                let attackDistance = 3;
        
                if (agentObj.state == 0) { // ideling
                    if (agentObj.idleTimeout <= 0) {
                        let randPos = navigationPlugin.getRandomPointAround(currAgentPos, 0.5);
                        //console.log("startingPoint: ", startingPoint, "randPos: ", randPos);
                        console.log("agent " + agentIdx + ": wandering to " + randPos);
                        agentObj.state = 1; // wandering
                        agentObj.wanderDest = randPos;
                        crowd.updateAgentParameters(agentIdx, { maxSpeed: 1 + 2 * Math.random() });
        
                        crowd.agentGoto(agentIdx, randPos);
                    } else {
                        agentObj.idleTimeout -= scene.getEngine().getDeltaTime(); // time between two frames in ms
                    }
                } else if (agentObj.state == 2) { // fleeing
                    //console.log('fleeing');
                    // check wether agent has reached it's flee distance
                    let wanderDestPos = agentObj.wanderDest;
                    let inCircle = isPointInCircle2D(
                        new BABYLON.Vector2(currAgentPos.x, currAgentPos.z),
                        new BABYLON.Vector2(wanderDestPos.x, wanderDestPos.z),
                        1
                    );
                    if (inCircle) {
                        // flee destiantion reached
                        // hack: set meta as if idling has been finished which leads to wandering
                        agentObj.idleTimeout = 0;
                        agentObj.state = 0
                    } else if (playerMode == 'victim') {
                        // cancel flee because player is now victim and should be attacked
                        console.log("agent " + agentIdx + ": flee canceled, player is now victim, initiatig agent attack");
                        initiateAttack(playerPos, agentIdx, agentObj, crowd);
                    } else {
                        // calculate agent's mesh rotation that it aligns with it's direction
                        rotateAgent(agentIdx, agentObj, crowd);
                    }
                } else if (agentObj.state == 3) { // attacking
                    //console.log('attacking');
                    // check wether agent still within attack range
                    let agentPlayerDistance = BABYLON.Vector3.Distance(currAgentPos, playerPos);
                    if (agentPlayerDistance > attackDistance) {
                        // agent istn't within attack distance anymore
                        // hack: set meta as if idling has been finished which leads to wandering
                        agentObj.idleTimeout = 0;
                        agentObj.state = 0
                    } else if (playerMode == 'hostile') {
                        // cancel attack because player is now hostile
                        console.log("agent " + agentIdx + ": attack canceled, player is now hostile, initiatig agent flee");
                        initiateFlee(playerPos, agentIdx, agentObj, crowd);
                    } else {
                        crowd.agentGoto(agentIdx, playerPos);
                        // calculate agent's mesh rotation that it aligns with it's direction
                        rotateAgent(agentIdx, agentObj, crowd);
                    }
                } else if (agentObj.state == 1) { // wandering
        
                    // calculate agent's mesh rotation that it aligns with it's direction
                    rotateAgent(agentIdx, agentObj, crowd);
        
                    // check if agent has arrived at it's destination /////////////////////////////////////////
        
                    let wanderDestPos = agentObj.wanderDest;
        
                    // wanderDestPos won't be reached exactly so check if currAgentPos lies in a circle witch center
                    // is wanderDestPos
        
                    let inCircle = isPointInCircle2D(
                        new BABYLON.Vector2(currAgentPos.x, currAgentPos.z),
                        new BABYLON.Vector2(wanderDestPos.x, wanderDestPos.z),
                        1
                    );
                    if (inCircle) {
                        // destination reached -> ideling
                        agentObj.idleTimeout = 3000 * Math.random(); // idle for max 3 sec
                        agentObj.state = 0;
                        console.log("agent " + agentIdx + ": ideling for " + agentObj.idleTimeout + " ms");
                        continue;
                    }
        
                    // agent flees from player if it's close to player
        
                    // flee code from: https://www.youtube.com/watch?v=Zjlg9F3FRJs
                    let distance = BABYLON.Vector3.Distance(currAgentPos, playerPos);
                    
                    if (playerMode == 'hostile') {
                        if (distance < fleeDistance) {
                            newAgentPos = initiateFlee(playerPos, agentIdx, agentObj, crowd);
                            console.log("agent " + agentIdx + ": fleeing to " + newAgentPos);
                            continue;
                        }
                    } else if (playerMode == 'victim') {
                        if (distance < attackDistance) {
                            initiateAttack(playerPos, agentIdx, agentObj, crowd);
                            console.log("agent " + agentIdx + ": attacking player, moving to " + playerPos);
                        }
                    }
                }
            }
        }
        
        function initiateFlee(playerPos, agentIdx, agentObj, crowd) {
            let currAgentPos = crowd.getAgentPosition(agentIdx);
            let dirToPlayer = currAgentPos.subtract(playerPos);
            let newAgentPos = currAgentPos.add(dirToPlayer);
            agentObj.wanderDest = newAgentPos;
            crowd.updateAgentParameters(agentIdx, { maxSpeed: 4 });
            crowd.agentGoto(agentIdx, newAgentPos);
            agentObj.state = 2; // fleeing
            return newAgentPos;
        }
        
        function initiateAttack(playerPos, agentIdx, agentObj, crowd) {
            agentObj.wanderDest = playerPos;
            crowd.updateAgentParameters(agentIdx, { maxSpeed: 4 });
            crowd.agentGoto(agentIdx, playerPos);
            agentObj.state = 3; // attacking
        }
        
        
        function isPointInCircle2D(point, circleCenter, circleRadius) {
            // https://www.youtube.com/watch?v=cHsl0baVz7A
            let distance = Math.sqrt(
                Math.pow((point.x - circleCenter.x), 2) +
                Math.pow((point.y - circleCenter.y), 2)
            );
            return (distance < circleRadius);
        }
        
        function rotateAgent(agentIdx, agentObj, crowd) {
            // calculate agent rotation that it aligns with it's direction ////////////////////
            // rotation code see:
            // https://forum.babylonjs.com/t/navigation-mesh-and-crowd-agents/4609/47
        
            let angleInterpolationFactor = 0.1;
            let velocity = crowd.getAgentVelocity(agentIdx);
            if (velocity.length() > 0.01) {
                velocity.normalize();
                agentObj.velocity = velocity;
        
                let dir = agentObj.direction;
        
                agentObj.direction = new BABYLON.Vector3(
                    dir.x + (agentObj.velocity.x - dir.x) * angleInterpolationFactor,
                    dir.y + (agentObj.velocity.y - dir.y) * angleInterpolationFactor,
                    dir.z + (agentObj.velocity.z - dir.z) * angleInterpolationFactor);
                agentObj.direction.normalize();
        
                let targetAngle = Math.PI * 0.5 - Math.atan2(agentObj.direction.z, agentObj.direction.x);
        
                agentObj.mesh.rotation.y = targetAngle;
            }
        }
        
        
        var createScene = async function () {
        
            // This creates a basic Babylon Scene object (non-mesh)
            let scene = new BABYLON.Scene(engine);
            let navigationPlugin = new BABYLON.RecastJSPlugin();
        
            // Setup environment
            let camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 200, new BABYLON.Vector3(-20, 23, -5), scene);
            camera.position = new BABYLON.Vector3(-25, 27, -13);
            //camera.lowerBetaLimit = 0.0;
            //camera.upperBetaLimit = (Math.PI / 2);
            //camera.lowerRadiusLimit = 30;
            camera.upperRadiusLimit = 80;
            camera.attachControl(canvas, true);
        
            // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            let light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            // Default intensity is 1. Let's dim the light a small amount
            light.intensity = 0.7;
        
            let navmeshParameters = {
                cs: 0.2,
                ch: 0.1,
                walkableSlopeAngle: 35,
                walkableHeight: 1,
                walkableClimb: 0.7, // 
                walkableRadius: 0.9,
                maxEdgeLen: 12.,
                maxSimplificationError: 1.3,
                minRegionArea: 8,
                mergeRegionArea: 20,
                maxVertsPerPoly: 6,
                detailSampleDist: 6,
                detailSampleMaxError: 1,
            };
        
            // Ground
        
            let ground = await createGroundFromHeightMapAsync(scene);
            let groundMaterial = new BABYLON.StandardMaterial("ground", scene);
            groundMaterial.diffuseTexture = new BABYLON.Texture("/textures/ground.jpg", scene);
            groundMaterial.diffuseTexture.uScale = 6;
            groundMaterial.diffuseTexture.vScale = 6;
            groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            ground.position.y = -2.05;
            ground.material = groundMaterial;
        
            computeNavmesh(navigationPlugin, scene, navmeshParameters);
        
            // initialize the crowd
        
            // important!:
            // 2nd param maxAgentRadius must be in the same area than the ones specified for the individual
            // agents or moving agents start to "jitter" if they approach  dynObstacleAgent
            let crowd = navigationPlugin.createCrowd(numAgents, numAgents, scene);
            for (let i = 0; i < numAgents; i++) {
                let width = 0.5;
                let agentMesh;
                if (i == playerAgentIdx) {
                    agentMesh = BABYLON.MeshBuilder.CreateIcoSphere("player", { radius: 0.4, subdivisions: 2, flat: true }, scene);
                } else {
                    agentMesh = BABYLON.MeshBuilder.CreateBox("agent", { size: width, height: width }, scene);
                    let agentLeftEye = BABYLON.MeshBuilder.CreateSphere("leftEye", { diameterX: width / 2, diameterY: width / 2, diameterZ: width / 2 }, scene);
                    agentLeftEye.position.x -= width / 4;
                    agentLeftEye.position.y += width / 2;
                    agentLeftEye.position.z += width / 4;
                    agentLeftEye.parent = agentMesh;
        
                    let agentRightEye = BABYLON.MeshBuilder.CreateSphere("rightEye", { diameterX: width / 2, diameterY: width / 2, diameterZ: width / 2 }, scene);
                    agentRightEye.position.x += width / 4;
                    agentRightEye.position.y += width / 2;
                    agentRightEye.position.z += width / 4;
                    agentRightEye.parent = agentMesh;
                }
                let matAgent = new BABYLON.StandardMaterial('mat2', scene);
                let variation = Math.random();
                matAgent.diffuseColor = new BABYLON.Color3(1, 1.0 - variation * 0.8, 1.0 - variation * 0.6);
                agentMesh.material = matAgent;
                // first parameter "position" can't be guessed but must be a coordinate
                // from the terrain's ground where a walkable navmesh area is. get the point via picking,
                // see getGroundPosition()
                let randomPos = navigationPlugin.getRandomPointAround(new BABYLON.Vector3(-5, 10, 3), 10);
                console.log("randomPos: " + randomPos);
                let transform = new BABYLON.TransformNode();
                agentMesh.position.y += .2;
                agentMesh.parent = transform;
        
                let agentParams = {
                    // must be near the size of the agent or they will intersect.
                    // note: that also collisionQueryRange must be adjusted or agents are "jittering"
                    radius: 0.5,
                    height: 0.5,
                    maxAcceleration: 10,
                    maxSpeed: 3,
                    collisionQueryRange: 10,
                    pathOptimizationRange: 0.1,
                    separationWeight: 2.0
                };
        
                if (i == playerAgentIdx) {
                    // playerAgent is going to be controlled via clicking on terrain
                    matAgent.diffuseColor = new BABYLON.Color3(0, 1, 0);
                    agentParams.radius = 1;
                    agentParams.maxSpeed = 5,
                    agentParams.collisionQueryRange = 0;
                }
        
                let agentIndex = crowd.addAgent(randomPos, agentParams, transform);
                agentsMeta[agentIndex] = {
                    mesh: agentMesh,
                    state: 0, // 0 = idele, 1 = wander, 2 = flee
                    idleTimeout: null,
                    wanderDest: null,
                    direction: new BABYLON.Vector3(1, 0, 0),
                    velocity: new BABYLON.Vector3(1, 0, 0)
                };
            }
        
        
            var playerModeToggle = false;
            scene.actionManager = new BABYLON.ActionManager(scene);
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, (evt) =>  {
                e = evt.sourceEvent;
                if (e.key === ' ' && !e.repeat) {
                    playerModeToggle = !playerModeToggle;
                    (playerModeToggle)
                        ? console.log('playerMode: victim')
                        : console.log('playerMode: hostile');
                }
            }));
        
            scene.onPointerObservable.add((pointerInfo) => {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        if (pointerInfo.pickInfo.hit) {
                            pointerDown(pointerInfo.pickInfo.pickedMesh, crowd, navigationPlugin, scene)
                        }
                        break;
                }
            });
        
            scene.onBeforeRenderObservable.add(() => {
                let playerMode = (playerModeToggle) ? 'victim' : 'hostile';
                wander(crowd, navigationPlugin, playerMode, scene);
            });
        
            return scene;
        }
                window.initFunction = async function() {
                    
                    await Recast();
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
                            
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
